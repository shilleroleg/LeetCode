"""
A. Камни и украшения [тестовая задача]
Ограничение времени 	1 секунда
Ограничение памяти 	64Mb
Ввод 	стандартный ввод или input.txt
Вывод 	стандартный вывод или output.txt
Даны две строки строчных латинских символов: строка J и строка S. Символы, входящие в строку J, — «драгоценности»,
входящие в строку S — «камни». Нужно определить, какое количество символов из S одновременно
являются «драгоценностями». Проще говоря, нужно проверить, какое количество символов из S входит в J.

Формат ввода
На двух первых строках входного файла содержатся две строки строчных латинских символов: строка J и строка S.
Длина каждой не превосходит 100 символов.
Формат вывода
Выходной файл должен содержать единственное число — количество камней, являющихся драгоценностями.
"""
import sys

j = sys.stdin.readline().strip()
s = sys.stdin.readline().strip()

result = 0
for ch in s:
    if ch in j:
        result += 1

print(result)


"""
B. Последовательно идущие единицы
Ограничение времени 	1 секунда
Ограничение памяти 	64Mb
Ввод 	стандартный ввод или input.txt
Вывод 	стандартный вывод или output.txt

Требуется найти в бинарном векторе самую длинную последовательность единиц и вывести её длину.

Желательно получить решение, работающее за линейное время и при этом проходящее по входному массиву только один раз.
Формат ввода

Первая строка входного файла содержит одно число n, n ≤ 10000. Каждая из следующих n строк содержит ровно одно число
— очередной элемент массива.
Формат вывода

Выходной файл должен содержать единственное число — длину самой длинной последовательности единиц во входном массиве.
Пример
Ввод
5
1
0
1
0
1

Вывод 1
"""

import sys

num = sys.stdin.readline().strip()

max_ = 0
cur_ = 0

for _ in range(int(num)):
    i = sys.stdin.readline().strip()
    if i == '1':
        cur_ += 1
        max_ = max(max_, cur_)
    else:
        cur_ = 0

print(max_)



"""
C. Удаление дубликатов

Дан упорядоченный по неубыванию массив целых 32-разрядных чисел. Требуется удалить из него все повторения.

Желательно получить решение, которое не считывает входной файл целиком в память, т.е.,
использует лишь константный объем памяти в процессе работы.

Input format

Первая строка входного файла содержит единственное число n, n ≤ 1000000.
На следующих n строк расположены числа — элементы массива, по одному на строку. Числа отсортированы по неубыванию.

Output format
Выходной файл должен содержать следующие в порядке возрастания уникальные элементы входного массива.
Sample 1
Input
5
2
4
8
8
8

Output
2
4
8
"""

import sys

num = int(sys.stdin.readline().strip())

out = []
ch = -1

for _ in range(num):
    i = int(sys.stdin.readline().strip())
    if i != ch:
        out.append(i)
    ch = i

for o in out:
    print(o)




"""
D. Дано целое число n. Требуется вывести все правильные скобочные последовательности длины 2 ⋅ n,
упорядоченные лексикографически.
В задаче используются только круглые скобки.
Желательно получить решение, которое работает за время, пропорциональное общему количеству
правильных скобочныхпоследовательностей в ответе, и при этом использует объём памяти,
пропорциональный n.
"""
import sys
n = int(sys.stdin.readline().strip())


def foo(s, l, r, pairs):
    if l == pairs and r == pairs:
        print(s)
    else:
        if l < pairs:
            foo(s + '(', l + 1, r, pairs)
        if r < l:
            foo(s + ')', l, r + 1, pairs)


foo('', 0, 0, n)

"""

"""
from collections import Counter
from math import gcd


def get_friend(x):
    c = Counter(x)
    flist = list(dict(c).values())
    result = gcd_list(flist)

    return result


def gcd_list(lst):
    gcds = []
    for i in range(len(lst) - 1):
        gcds.append(gcd(lst[i], lst[i+1]))
    return min(gcds)


if __name__ == '__main__':
    cand = ["a", "b", "c", "a", "b", "c", "c", "c"]
    res = get_friend(cand)
    print(res)

    cand = ["a", "a", "a", "b", "b", "b", "b", "c", "c", "c", "c", "c"]
    res = get_friend(cand)
    print(res)